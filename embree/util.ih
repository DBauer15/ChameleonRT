#pragma once

#include "float3.ih"

#define M_PI 3.14159265358979323846
#define M_1_PI 0.318309886183790671538
#define EPSILON 0.0001

#define MAX_PATH_DEPTH 5

typedef unsigned int8 uint8_t;
typedef unsigned int uint32_t;
typedef unsigned int64 uint64_t;

float linear_to_srgb(float x) {
	if (x <= 0.0031308f) {
		return 12.92f * x;
	}
	return 1.055f * pow(x, 1.f/2.4f) - 0.055f;
}

float luminance(const float3 &c) {
	return 0.2126f * c.x + 0.7152f * c.y + 0.0722f * c.z;
}

float pow2(float x) {
	return x * x;
}

void ortho_basis(float3 &v_x, float3 &v_y, const float3 &n) {
	v_y = make_float3(0.f);

	if (n.x < 0.6f && n.x > -0.6f) {
		v_y.x = 1.f;
	} else if (n.y < 0.6f && n.y > -0.6f) {
		v_y.y = 1.f;
	} else if (n.z < 0.6f && n.z > -0.6f) {
		v_y.z = 1.f;
	} else {
		v_y.x = 1.f;
	}
	v_x = normalize(cross(v_y, n));
	v_y = normalize(cross(n, v_x));
}

// Utils from HLSL
float saturate(float x) {
	return clamp(x, 0.f, 1.f);
}

float lerp(float x, float y, float s) {
	return x * (1.f - s) + y * s;
}

float3 lerp(float3 x, float3 y, float s) {
	return x * (1.f - s) + y * s;
}

float3 reflect(const float3 &i, const float3 &n) {
	return i - 2.f * n * dot(i, n);
}

float3 refract(const float3 &i, const float3 &n, float eta) {
	float n_dot_i = dot(n, i);
	float k = 1.f - eta * eta * (1.f - pow2(n_dot_i));
	if (k < 0.f) {
		return make_float3(0.f);
	}
	return eta * i - (eta * n_dot_i + sqrt(k)) * n;
}

