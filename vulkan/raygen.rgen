#version 460

#include "util.glsl"
#include "pcg_rng.glsl"

struct DisneyMaterial {
    pack_float3 base_color;
    float metallic;

    float specular;
    float roughness;
    float specular_tint;
    float anisotropy;

    float sheen;
    float sheen_tint;
    float clearcoat;
    float clearcoat_gloss;

    float ior;
    float specular_transmission;
    vec2 pad;

    uint color_tex_id;
    pack_uint3 tex_pad;
};

layout(binding = 0, set = 0) uniform accelerationStructureNV scene;
layout(binding = 1, set = 0, rgba8) uniform writeonly image2D framebuffer;

layout(binding = 2, set = 0, std140) uniform ViewParams {
    vec4 cam_pos;
    vec4 cam_du;
    vec4 cam_dv;
    vec4 cam_dir_top_left;
    int frame_id;
};

layout(binding = 3, set = 0, std430) buffer MaterialParams {
    DisneyMaterial materials[];
};

layout(binding = 0, set = 5) uniform sampler2D textures[];

layout(location = PRIMARY_RAY) rayPayloadNV RayPayload payload;

layout(location = OCCLUSION_RAY) rayPayloadNV bool occlusion_hit;

void main() {
    const ivec2 pixel = ivec2(gl_LaunchIDNV.xy);
    const vec2 dims = vec2(gl_LaunchSizeNV.xy);
    PCGRand rng = get_rng(frame_id);
    vec2 d = (pixel + vec2(pcg32_randomf(rng), pcg32_randomf(rng))) / dims;

    vec3 origin = cam_pos.xyz;
    vec3 dir = normalize(d.x * cam_du.xyz + d.y * cam_dv.xyz + cam_dir_top_left.xyz);
    float t_min = 0;
    float t_max = 1e20f;

    // TODO Opaque = disable any hit?
    traceNV(scene, gl_RayFlagsOpaqueNV, 0xff, PRIMARY_RAY, 0, PRIMARY_RAY,
            origin, t_min, dir, t_max, PRIMARY_RAY);

    vec3 shade_color = vec3(0);
    if (payload.dist > 0.f) {
        DisneyMaterial mat = materials[nonuniformEXT(payload.material_id)];
        shade_color.x = mat.base_color.x;
        shade_color.y = mat.base_color.y;
        shade_color.z = mat.base_color.z;

        if (mat.color_tex_id != uint(-1)) {
            shade_color = texture(textures[nonuniformEXT(mat.color_tex_id)], payload.uv).xyz;
        }
        shade_color *= abs(dot(payload.normal, dir));

        occlusion_hit = false;
        // Now trace a shadow ray to a "light"
        vec3 light_dir = normalize(vec3(0.2f, 1.f, 0.5f));
        vec3 hit_p = origin + dir * payload.dist;
        // TODO: In all backends could use the skip closest hit flag here
        traceNV(scene, gl_RayFlagsTerminateOnFirstHitNV | gl_RayFlagsOpaqueNV, 0xff,
                OCCLUSION_RAY, 0, OCCLUSION_RAY, hit_p, EPSILON, light_dir, t_max, OCCLUSION_RAY);
        if (occlusion_hit) {
            shade_color *= 0.5;
        }
    }

    imageStore(framebuffer, pixel, vec4(shade_color, 1.f));
}

